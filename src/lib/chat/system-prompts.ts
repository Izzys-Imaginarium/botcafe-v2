/**
 * System Prompts Service
 *
 * Fetches and caches configurable prompt templates from the database.
 * Provides fallbacks to default prompts if none are configured.
 */

import type { Payload } from 'payload'

export type PromptType =
  | 'roleplay_intro'
  | 'knowledge_instructions'
  | 'roleplay_guidelines'
  | 'multibot_instructions'
  | 'ai_disclaimer'

interface SystemPrompt {
  id: number
  promptType: PromptType
  content: string
  isActive: boolean
}

// In-memory cache with 5 minute TTL
let promptCache: Map<PromptType, string> | null = null
let cacheTimestamp = 0
const CACHE_TTL_MS = 5 * 60 * 1000 // 5 minutes

/**
 * Default prompts used when no custom prompts are configured
 */
export const DEFAULT_PROMPTS: Record<PromptType, string> = {
  roleplay_intro: `You are roleplaying as {{bot_name}}. Stay in character at all times and respond as {{bot_name}} would.`,

  knowledge_instructions: `You have access to different types of knowledge that may be provided:
- Memories: Specific memories or past interactions - prioritize these when relevant
- Bot Persona: Your character traits, background, and personality details
- User Persona: Traits and preferences of the person you're talking to
- Lore: Worldbuilding context relevant to your setting
- General: Supplementary information that doesn't fit other categories

When responding, naturally incorporate relevant memories, traits, lore, and knowledge. Do not explicitly reference these categories or say things like "according to my memories" or "based on the lore". Instead, speak as if this knowledge is simply part of who you are and what you know.`,

  roleplay_guidelines: `- Stay in character as {{bot_name}} throughout the conversation
- Respond naturally to the user's messages as {{bot_name}} would
- Use your established personality, speech patterns, and mannerisms
- If the user refers to you by a different name, gently correct them in character
- Engage with the conversation topic while maintaining your character's perspective
- Keep content appropriate and respectful`,

  multibot_instructions: `This is a group conversation. Other characters present:
{{other_bots}}

When responding, only speak as {{bot_name}}. Do not speak for the other characters or the user.`,

  ai_disclaimer: `---
*This is an AI character. All responses are generated by artificial intelligence.*`,
}

/**
 * Fetch all active system prompts from the database
 */
async function fetchActivePrompts(payload: Payload): Promise<Map<PromptType, string>> {
  const prompts = new Map<PromptType, string>()

  try {
    const result = await payload.find({
      collection: 'system-prompts',
      where: {
        isActive: { equals: true },
      },
      sort: '-priority',
      limit: 100,
      overrideAccess: true,
    })

    for (const doc of result.docs) {
      const prompt = doc as unknown as SystemPrompt
      // Only store the first (highest priority) active prompt for each type
      if (!prompts.has(prompt.promptType)) {
        prompts.set(prompt.promptType, prompt.content)
      }
    }
  } catch (error) {
    console.error('[SystemPrompts] Failed to fetch prompts:', error)
    // Return empty map, will fall back to defaults
  }

  return prompts
}

/**
 * Apply placeholder replacements to prompt content
 * Supports both {{bot_name}}/{{user_name}} and {{char}}/{{user}} formats
 */
function applyReplacements(content: string, replacements?: Record<string, string>): string {
  if (!replacements) return content

  let result = content

  // Apply direct replacements
  for (const [key, value] of Object.entries(replacements)) {
    result = result.replaceAll(`{{${key}}}`, value)
  }

  // Support common roleplay placeholder aliases
  // {{char}} is an alias for {{bot_name}}
  if (replacements.bot_name) {
    result = result.replaceAll('{{char}}', replacements.bot_name)
  }
  // {{user}} is an alias for {{user_name}}
  if (replacements.user_name) {
    result = result.replaceAll('{{user}}', replacements.user_name)
  }

  return result
}

/**
 * Get a specific prompt by type with caching
 * Falls back to default if no custom prompt exists
 */
export async function getPrompt(
  payload: Payload,
  type: PromptType,
  replacements?: Record<string, string>
): Promise<string> {
  // Check if cache is still valid
  const now = Date.now()
  if (!promptCache || (now - cacheTimestamp) > CACHE_TTL_MS) {
    promptCache = await fetchActivePrompts(payload)
    cacheTimestamp = now
  }

  // Get prompt from cache or use default
  const content = promptCache.get(type) || DEFAULT_PROMPTS[type]

  return applyReplacements(content, replacements)
}

/**
 * Get all prompts at once (more efficient for building full context)
 */
export async function getAllPrompts(
  payload: Payload,
  replacements?: Record<string, string>
): Promise<Record<PromptType, string>> {
  // Check if cache is still valid
  const now = Date.now()
  if (!promptCache || (now - cacheTimestamp) > CACHE_TTL_MS) {
    promptCache = await fetchActivePrompts(payload)
    cacheTimestamp = now
  }

  const result: Record<PromptType, string> = {} as Record<PromptType, string>

  for (const type of Object.keys(DEFAULT_PROMPTS) as PromptType[]) {
    const content = promptCache.get(type) || DEFAULT_PROMPTS[type]
    result[type] = applyReplacements(content, replacements)
  }

  return result
}

/**
 * Clear the prompt cache (call after admin updates prompts)
 */
export function clearPromptCache(): void {
  promptCache = null
  cacheTimestamp = 0
}
